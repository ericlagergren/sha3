use core::{error, fmt};

use generic_array::{typenum::Unsigned, ArrayLength, GenericArray};
use sha3::{
    digest::{
        core_api::{Block, CoreProxy, UpdateCore},
        crypto_common::{AlgorithmName, BlockSizeUser},
        ExtendableOutput, Update, XofReader,
    },
    CShake128, CShake256,
};
use sha3_utils::{bytepad_blocks, encode_string, right_encode, right_encode_bytes};

/// Returned when the key is too small.
#[derive(Copy, Clone, Debug, Eq, PartialEq)]
pub struct InvalidLength;

impl fmt::Display for InvalidLength {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "invalid length")
    }
}

impl error::Error for InvalidLength {}

/// A message authentication code.
pub type Mac<N> = GenericArray<u8, N>;

macro_rules! impl_kmac {
    ($alg:literal, $name:ident, $cshake:ty, $security:literal) => {
        #[doc = "`"]
        #[doc = $alg]
        #[doc = "`."]
        #[derive(Clone, Debug)]
        pub struct $name {
            cshake: $cshake,
        }

        impl $name {
            /// The minimum allowed size, in bytes, of a key.
            pub const MIN_KEY_SIZE: usize = $security / 8;

            /// Crates a new KMAC instance with key `k` and
            /// customization string `s`.
            ///
            /// - `k` must be at least
            ///   [`MIN_KEY_SIZE`][Self::MIN_KEY_SIZE].
            /// - `s` can be any length, including the empty
            ///   string.
            pub fn new(k: &[u8], s: &[u8]) -> Result<Self, InvalidLength> {
                if k.len() < Self::MIN_KEY_SIZE {
                    return Err(InvalidLength);
                }

                let mut core = <$cshake as CoreProxy>::Core::new_with_function_name(b"KMAC", s);

                // NB: This is the same thing as
                //     const RATE: usize = <$cshake as BlockSizeUser>::BlockSize::USIZE;
                //     for s in &bytepad::<RATE>(encode_string(k)) {
                //         cshake.update(s);
                //     }
                // but avoids a panicking branch.
                const BLOCK_SIZE: usize = <$cshake as BlockSizeUser>::BlockSize::USIZE;
                let (head, mid, tail) = bytepad_blocks::<BLOCK_SIZE>(encode_string(k));
                core.update_blocks(&[*Block::<$cshake>::from_slice(&head)]);
                if !mid.is_empty() {
                    core.update_blocks(
                        // SAFETY: `[u8; BLOCK_SIZE]` and
                        // `Block<$cshake>` has the same layout in
                        // memory.
                        unsafe { &*(mid as *const [[u8; BLOCK_SIZE]] as *const [Block<$cshake>]) },
                    );
                }
                if let Some(tail) = tail {
                    core.update_blocks(&[*Block::<$cshake>::from_slice(&tail)]);
                }

                let cshake = <$cshake>::from_core(core);

                Ok(Self { cshake })
            }

            /// Writes `data` to the running MAC state.
            #[inline]
            pub fn update(&mut self, data: &[u8]) {
                self.cshake.update(data);
            }

            /// Returns a fixed-size output.
            pub fn finalize_into(mut self, out: &mut [u8]) {
                self.cshake.update(right_encode_bytes(out.len()).as_bytes());
                self.cshake.finalize_xof().read(out)
            }

            /// Returns a fixed-size MAC.
            pub fn finalize<N: ArrayLength>(self) -> Mac<N> {
                let mut out = Mac::default();
                self.finalize_into(&mut out);
                out
            }
        }

        impl AlgorithmName for $name {
            fn write_alg_name(f: &mut fmt::Formatter<'_>) -> fmt::Result {
                write!(f, $alg)
            }
        }

        impl Update for $name {
            #[inline]
            fn update(&mut self, data: &[u8]) {
                self.update(data);
            }
        }
    };
}
impl_kmac!("KMAC128", Kmac128, CShake128, 128);
impl_kmac!("KMAC256", Kmac256, CShake256, 256);

macro_rules! impl_kmac_xof {
    ($alg:literal, $name:ident, $cshake:ty, $security:literal) => {
        #[doc = "`"]
        #[doc = $alg]
        #[doc = "`."]
        #[derive(Clone, Debug)]
        pub struct $name {
            cshake: $cshake,
        }

        impl $name {
            /// The minimum allowed size, in bytes, of a key.
            pub const MIN_KEY_SIZE: usize = $security / 8;

            /// Crates a new KMACXOF instance with the key `k`
            /// and customization string `s`.
            ///
            /// - `k` must be at least
            ///   [`MIN_KEY_SIZE`][Self::MIN_KEY_SIZE].
            /// - `s` can be any length, including the empty
            ///   string.
            pub fn new(k: &[u8], s: &[u8]) -> Result<Self, InvalidLength> {
                if k.len() < Self::MIN_KEY_SIZE {
                    return Err(InvalidLength);
                }

                let mut core = <$cshake as CoreProxy>::Core::new_with_function_name(b"KMAC", s);

                // NB: This is the same thing as
                //     const RATE: usize = <$cshake as BlockSizeUser>::BlockSize::USIZE;
                //     for s in &bytepad::<RATE>(encode_string(k)) {
                //         cshake.update(s);
                //     }
                // but avoids a panicking branch.
                const BLOCK_SIZE: usize = <$cshake as BlockSizeUser>::BlockSize::USIZE;
                let (head, mid, tail) = bytepad_blocks::<BLOCK_SIZE>(encode_string(k));
                core.update_blocks(&[*Block::<$cshake>::from_slice(&head)]);
                if !mid.is_empty() {
                    core.update_blocks(
                        // SAFETY: `[u8; BLOCK_SIZE]` and
                        // `Block<$cshake>` has the same layout in
                        // memory.
                        unsafe { &*(mid as *const [[u8; BLOCK_SIZE]] as *const [Block<$cshake>]) },
                    );
                }
                if let Some(tail) = tail {
                    core.update_blocks(&[*Block::<$cshake>::from_slice(&tail)]);
                }

                let cshake = <$cshake>::from_core(core);

                Ok(Self { cshake })
            }

            /// Writes `data` to the running MAC state.
            #[inline]
            pub fn update(&mut self, data: &[u8]) {
                self.cshake.update(data);
            }

            /// Returns a fixed-size output.
            pub fn finalize_xof(mut self) -> <$cshake as ExtendableOutput>::Reader {
                self.cshake.update(right_encode(0).as_bytes());
                self.cshake.finalize_xof()
            }
        }

        impl AlgorithmName for $name {
            fn write_alg_name(f: &mut fmt::Formatter<'_>) -> fmt::Result {
                write!(f, $alg)
            }
        }

        impl ExtendableOutput for $name {
            type Reader = <$cshake as ExtendableOutput>::Reader;

            #[inline]
            fn finalize_xof(self) -> Self::Reader {
                self.finalize_xof()
            }
        }

        impl Update for $name {
            #[inline]
            fn update(&mut self, data: &[u8]) {
                self.update(data);
            }
        }
    };
}
impl_kmac_xof!("KMACXOF128", KmacXof128, CShake128, 128);
impl_kmac_xof!("KMACXOF256", KmacXof256, CShake256, 256);

#[cfg(test)]
#[allow(clippy::type_complexity, reason = "Tests")]
mod tests {
    use generic_array::typenum::{U32, U64};

    use super::*;

    // https://csrc.nist.gov/CSRC/media/Projects/Cryptographic-Standards-and-Guidelines/documents/examples/KMAC_samples.pdf
    #[test]
    fn test_kmac128() {
        let vectors: &[(&[u8], &[u8], &[u8], &[u8])] = &[
            (
                &[
                    0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C,
                    0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59,
                    0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,
                ],
                &[0x00, 0x01, 0x02, 0x03],
                &[],
                &[
                    0xE5, 0x78, 0x0B, 0x0D, 0x3E, 0xA6, 0xF7, 0xD3, 0xA4, 0x29, 0xC5, 0x70, 0x6A,
                    0xA4, 0x3A, 0x00, 0xFA, 0xDB, 0xD7, 0xD4, 0x96, 0x28, 0x83, 0x9E, 0x31, 0x87,
                    0x24, 0x3F, 0x45, 0x6E, 0xE1, 0x4E,
                ],
            ),
            (
                &[
                    0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C,
                    0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59,
                    0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,
                ],
                &[0x00, 0x01, 0x02, 0x03],
                b"My Tagged Application",
                &[
                    0x3B, 0x1F, 0xBA, 0x96, 0x3C, 0xD8, 0xB0, 0xB5, 0x9E, 0x8C, 0x1A, 0x6D, 0x71,
                    0x88, 0x8B, 0x71, 0x43, 0x65, 0x1A, 0xF8, 0xBA, 0x0A, 0x70, 0x70, 0xC0, 0x97,
                    0x9E, 0x28, 0x11, 0x32, 0x4A, 0xA5,
                ],
            ),
        ];
        for (i, &(k, data, s, want)) in vectors.iter().enumerate() {
            let mut m = Kmac128::new(k, s).unwrap();
            m.update(data);
            let got = m.finalize::<U32>();
            let want = Mac::<U32>::from_slice(want);
            assert_eq!(&got, want, "#{i}");
        }
    }

    // https://csrc.nist.gov/CSRC/media/Projects/Cryptographic-Standards-and-Guidelines/documents/examples/KMAC_samples.pdf
    #[test]
    fn test_kmac256() {
        let vectors: &[(&[u8], &[u8], &[u8], &[u8])] = &[
            (
                &[
                    0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C,
                    0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59,
                    0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,
                ],
                &[0x00, 0x01, 0x02, 0x03],
                b"My Tagged Application",
                &[
                    0x20, 0xC5, 0x70, 0xC3, 0x13, 0x46, 0xF7, 0x03, 0xC9, 0xAC, 0x36, 0xC6, 0x1C,
                    0x03, 0xCB, 0x64, 0xC3, 0x97, 0x0D, 0x0C, 0xFC, 0x78, 0x7E, 0x9B, 0x79, 0x59,
                    0x9D, 0x27, 0x3A, 0x68, 0xD2, 0xF7, 0xF6, 0x9D, 0x4C, 0xC3, 0xDE, 0x9D, 0x10,
                    0x4A, 0x35, 0x16, 0x89, 0xF2, 0x7C, 0xF6, 0xF5, 0x95, 0x1F, 0x01, 0x03, 0xF3,
                    0x3F, 0x4F, 0x24, 0x87, 0x10, 0x24, 0xD9, 0xC2, 0x77, 0x73, 0xA8, 0xDD,
                ],
            ),
            (
                &[
                    0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C,
                    0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59,
                    0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,
                ],
                &[
                    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C,
                    0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19,
                    0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26,
                    0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33,
                    0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x40,
                    0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D,
                    0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A,
                    0x5B, 0x5C, 0x5D, 0x5E, 0x5F, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
                    0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74,
                    0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F, 0x80, 0x81,
                    0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E,
                    0x8F, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B,
                    0x9C, 0x9D, 0x9E, 0x9F, 0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8,
                    0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF, 0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5,
                    0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF, 0xC0, 0xC1, 0xC2,
                    0xC3, 0xC4, 0xC5, 0xC6, 0xC7,
                ],
                &[],
                &[
                    0x75, 0x35, 0x8C, 0xF3, 0x9E, 0x41, 0x49, 0x4E, 0x94, 0x97, 0x07, 0x92, 0x7C,
                    0xEE, 0x0A, 0xF2, 0x0A, 0x3F, 0xF5, 0x53, 0x90, 0x4C, 0x86, 0xB0, 0x8F, 0x21,
                    0xCC, 0x41, 0x4B, 0xCF, 0xD6, 0x91, 0x58, 0x9D, 0x27, 0xCF, 0x5E, 0x15, 0x36,
                    0x9C, 0xBB, 0xFF, 0x8B, 0x9A, 0x4C, 0x2E, 0xB1, 0x78, 0x00, 0x85, 0x5D, 0x02,
                    0x35, 0xFF, 0x63, 0x5D, 0xA8, 0x25, 0x33, 0xEC, 0x6B, 0x75, 0x9B, 0x69,
                ],
            ),
            (
                &[
                    0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C,
                    0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59,
                    0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,
                ],
                &[
                    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C,
                    0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19,
                    0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26,
                    0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33,
                    0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x40,
                    0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D,
                    0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A,
                    0x5B, 0x5C, 0x5D, 0x5E, 0x5F, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
                    0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74,
                    0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F, 0x80, 0x81,
                    0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E,
                    0x8F, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B,
                    0x9C, 0x9D, 0x9E, 0x9F, 0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8,
                    0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF, 0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5,
                    0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF, 0xC0, 0xC1, 0xC2,
                    0xC3, 0xC4, 0xC5, 0xC6, 0xC7,
                ],
                b"My Tagged Application",
                &[
                    0xB5, 0x86, 0x18, 0xF7, 0x1F, 0x92, 0xE1, 0xD5, 0x6C, 0x1B, 0x8C, 0x55, 0xDD,
                    0xD7, 0xCD, 0x18, 0x8B, 0x97, 0xB4, 0xCA, 0x4D, 0x99, 0x83, 0x1E, 0xB2, 0x69,
                    0x9A, 0x83, 0x7D, 0xA2, 0xE4, 0xD9, 0x70, 0xFB, 0xAC, 0xFD, 0xE5, 0x00, 0x33,
                    0xAE, 0xA5, 0x85, 0xF1, 0xA2, 0x70, 0x85, 0x10, 0xC3, 0x2D, 0x07, 0x88, 0x08,
                    0x01, 0xBD, 0x18, 0x28, 0x98, 0xFE, 0x47, 0x68, 0x76, 0xFC, 0x89, 0x65,
                ],
            ),
        ];
        for (i, &(k, data, s, want)) in vectors.iter().enumerate() {
            let mut m = Kmac256::new(k, s).unwrap();
            m.update(data);
            let got = m.finalize::<U64>();
            let want = Mac::<U64>::from_slice(want);
            assert_eq!(&got, want, "#{i}");
        }
    }

    // https://csrc.nist.gov/CSRC/media/Projects/Cryptographic-Standards-and-Guidelines/documents/examples/KMACXOF_samples.pdf
    #[test]
    fn test_kmacxof128() {
        let vectors: &[(&[u8], &[u8], &[u8], &[u8])] = &[
            (
                &[
                    0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C,
                    0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59,
                    0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,
                ],
                &[0x00, 0x01, 0x02, 0x03],
                &[],
                &[
                    0xCD, 0x83, 0x74, 0x0B, 0xBD, 0x92, 0xCC, 0xC8, 0xCF, 0x03, 0x2B, 0x14, 0x81,
                    0xA0, 0xF4, 0x46, 0x0E, 0x7C, 0xA9, 0xDD, 0x12, 0xB0, 0x8A, 0x0C, 0x40, 0x31,
                    0x17, 0x8B, 0xAC, 0xD6, 0xEC, 0x35,
                ],
            ),
            (
                &[
                    0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C,
                    0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59,
                    0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,
                ],
                &[0x00, 0x01, 0x02, 0x03],
                b"My Tagged Application",
                &[
                    0x31, 0xA4, 0x45, 0x27, 0xB4, 0xED, 0x9F, 0x5C, 0x61, 0x01, 0xD1, 0x1D, 0xE6,
                    0xD2, 0x6F, 0x06, 0x20, 0xAA, 0x5C, 0x34, 0x1D, 0xEF, 0x41, 0x29, 0x96, 0x57,
                    0xFE, 0x9D, 0xF1, 0xA3, 0xB1, 0x6C,
                ],
            ),
        ];
        for (i, &(k, data, s, want)) in vectors.iter().enumerate() {
            let mut m = KmacXof128::new(k, s).unwrap();
            m.update(data);
            let got = m.finalize_xof().read_boxed(32);
            assert_eq!(&*got, want, "#{i}");
        }
    }

    // https://csrc.nist.gov/CSRC/media/Projects/Cryptographic-Standards-and-Guidelines/documents/examples/KMACXOF_samples.pdf
    #[test]
    fn test_kmacxof256() {
        let vectors: &[(&[u8], &[u8], &[u8], &[u8])] = &[
            (
                &[
                    0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C,
                    0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59,
                    0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,
                ],
                &[0x00, 0x01, 0x02, 0x03],
                b"My Tagged Application",
                &[
                    0x17, 0x55, 0x13, 0x3F, 0x15, 0x34, 0x75, 0x2A, 0xAD, 0x07, 0x48, 0xF2, 0xC7,
                    0x06, 0xFB, 0x5C, 0x78, 0x45, 0x12, 0xCA, 0xB8, 0x35, 0xCD, 0x15, 0x67, 0x6B,
                    0x16, 0xC0, 0xC6, 0x64, 0x7F, 0xA9, 0x6F, 0xAA, 0x7A, 0xF6, 0x34, 0xA0, 0xBF,
                    0x8F, 0xF6, 0xDF, 0x39, 0x37, 0x4F, 0xA0, 0x0F, 0xAD, 0x9A, 0x39, 0xE3, 0x22,
                    0xA7, 0xC9, 0x20, 0x65, 0xA6, 0x4E, 0xB1, 0xFB, 0x08, 0x01, 0xEB, 0x2B,
                ],
            ),
            (
                &[
                    0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C,
                    0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59,
                    0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,
                ],
                &[
                    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C,
                    0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19,
                    0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26,
                    0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33,
                    0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x40,
                    0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D,
                    0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A,
                    0x5B, 0x5C, 0x5D, 0x5E, 0x5F, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
                    0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74,
                    0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F, 0x80, 0x81,
                    0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E,
                    0x8F, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B,
                    0x9C, 0x9D, 0x9E, 0x9F, 0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8,
                    0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF, 0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5,
                    0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF, 0xC0, 0xC1, 0xC2,
                    0xC3, 0xC4, 0xC5, 0xC6, 0xC7,
                ],
                &[],
                &[
                    0xFF, 0x7B, 0x17, 0x1F, 0x1E, 0x8A, 0x2B, 0x24, 0x68, 0x3E, 0xED, 0x37, 0x83,
                    0x0E, 0xE7, 0x97, 0x53, 0x8B, 0xA8, 0xDC, 0x56, 0x3F, 0x6D, 0xA1, 0xE6, 0x67,
                    0x39, 0x1A, 0x75, 0xED, 0xC0, 0x2C, 0xA6, 0x33, 0x07, 0x9F, 0x81, 0xCE, 0x12,
                    0xA2, 0x5F, 0x45, 0x61, 0x5E, 0xC8, 0x99, 0x72, 0x03, 0x1D, 0x18, 0x33, 0x73,
                    0x31, 0xD2, 0x4C, 0xEB, 0x8F, 0x8C, 0xA8, 0xE6, 0xA1, 0x9F, 0xD9, 0x8B,
                ],
            ),
            (
                &[
                    0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C,
                    0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59,
                    0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,
                ],
                &[
                    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C,
                    0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19,
                    0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26,
                    0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33,
                    0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x40,
                    0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D,
                    0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A,
                    0x5B, 0x5C, 0x5D, 0x5E, 0x5F, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
                    0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74,
                    0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F, 0x80, 0x81,
                    0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E,
                    0x8F, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B,
                    0x9C, 0x9D, 0x9E, 0x9F, 0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8,
                    0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF, 0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5,
                    0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF, 0xC0, 0xC1, 0xC2,
                    0xC3, 0xC4, 0xC5, 0xC6, 0xC7,
                ],
                b"My Tagged Application",
                &[
                    0xD5, 0xBE, 0x73, 0x1C, 0x95, 0x4E, 0xD7, 0x73, 0x28, 0x46, 0xBB, 0x59, 0xDB,
                    0xE3, 0xA8, 0xE3, 0x0F, 0x83, 0xE7, 0x7A, 0x4B, 0xFF, 0x44, 0x59, 0xF2, 0xF1,
                    0xC2, 0xB4, 0xEC, 0xEB, 0xB8, 0xCE, 0x67, 0xBA, 0x01, 0xC6, 0x2E, 0x8A, 0xB8,
                    0x57, 0x8D, 0x2D, 0x49, 0x9B, 0xD1, 0xBB, 0x27, 0x67, 0x68, 0x78, 0x11, 0x90,
                    0x02, 0x0A, 0x30, 0x6A, 0x97, 0xDE, 0x28, 0x1D, 0xCC, 0x30, 0x30, 0x5D,
                ],
            ),
        ];
        for (i, &(k, data, s, want)) in vectors.iter().enumerate() {
            let mut m = KmacXof256::new(k, s).unwrap();
            m.update(data);
            let got = m.finalize_xof().read_boxed(64);
            assert_eq!(&*got, want, "#{i}");
        }
    }
}
